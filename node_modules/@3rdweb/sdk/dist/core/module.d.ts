import { AccessControlEnumerable } from "@3rdweb/contracts";
import { Log, Provider, TransactionReceipt } from "@ethersproject/providers";
import { BaseContract, CallOverrides, Signer } from "ethers";
import type { ISDKOptions, ThirdwebSDK } from ".";
import { ModuleType } from "../common/module-type";
import { Role } from "../common/role";
import { ModuleMetadata } from "../types/ModuleMetadata";
import type { MetadataURIOrObject, ProviderOrSigner } from "./types";
/**
 * The root Module class. All other Modules extend this.
 * @remarks This should never be instantiated directly.
 * @public
 */
export declare class Module<TContract extends BaseContract = BaseContract> {
    /**
     * @readonly
     */
    readonly address: string;
    /**
     * @internal
     * @readonly
     */
    protected readonly ipfsGatewayUrl: string;
    /**
     * @internal
     * @readonly
     */
    protected readonly options: ISDKOptions;
    protected readonly sdk: ThirdwebSDK;
    /**
     * @internal
     */
    private _providerOrSigner;
    /**
     * @internal
     */
    protected get providerOrSigner(): ProviderOrSigner;
    private set providerOrSigner(value);
    /**
     * @internal
     */
    private _signer;
    /**
     * @internal
     */
    protected get signer(): Signer | null;
    private set signer(value);
    /**
     * Contract connects to the SDK signer or provider
     * @internal
     */
    contract: TContract;
    /**
     * Contract connects to the {@link ISDKOptions.readOnlyRpcUrl} if provided, otherwise connect to signer or provider
     * @internal
     */
    readOnlyContract: TContract;
    /**
     * @internal
     */
    constructor(providerOrSigner: ProviderOrSigner, address: string, options: ISDKOptions, sdk: ThirdwebSDK);
    /**
     * @public
     * @returns whether the given contract exists on-chain
     */
    exists(): Promise<boolean>;
    /**
     * @public
     * Get the metadata of the contract.
     */
    getMetadata(): Promise<ModuleMetadata>;
    /**
     * @public
     * Set new metadata on the contract and return it if successful.
     * @param metadata - The metadata to set.
     */
    setMetadata(metadata: MetadataURIOrObject): Promise<ModuleMetadata>;
    /**
     * @internal
     */
    setProviderOrSigner(providerOrSigner: ProviderOrSigner): void;
    /**
     * @internal
     */
    clearSigner(): void;
    /**
     * @internal
     */
    private getProviderOrSigner;
    /**
     * @internal
     */
    protected getSigner(): Signer | null;
    /**
     * @internal
     */
    protected hasValidSigner(): boolean;
    /**
     * @internal
     */
    protected getSignerAddress(): Promise<string>;
    /**
     * @internal
     */
    protected getProvider(): Promise<Provider | undefined>;
    /**
     * @internal
     */
    protected getChainID(): Promise<number>;
    /**
     * @virtual
     * @internal
     */
    protected connectContract(): TContract;
    /**
     * @virtual
     * @internal
     */
    protected getModuleType(): ModuleType;
    /**
     * @internal
     */
    protected getCallOverrides(): Promise<CallOverrides>;
    /**
     * @internal
     */
    protected sendTransaction(fn: string, args: any[], callOverrides?: CallOverrides): Promise<TransactionReceipt>;
    /**
     * @internal
     */
    private sendAndWaitForTransaction;
    /**
     * @internal
     */
    private sendGaslessTransaction;
    protected parseEventLogs(eventName: string, logs?: Log[]): any;
}
/**
 * Extends the {@link Module} class to add {@link Role} functionality.
 *
 * @public
 */
export declare class ModuleWithRoles<TContract extends AccessControlEnumerable = AccessControlEnumerable> extends Module<TContract> {
    /**
     * @virtual
     * @internal
     */
    protected getModuleRoles(): readonly Role[];
    /**
     * @internal
     */
    private get roles();
    /** @internal */
    constructor(providerOrSigner: ProviderOrSigner, address: string, options: ISDKOptions, sdk: ThirdwebSDK);
    /**
     * Call this to get a list of addresses that are members of a specific role.
     *
     * @param role - The {@link IRoles | role} to to get a memberlist for.
     * @returns The list of addresses that are members of the specific role.
     * @throws If you are requestiong a role that does not exist on the module this will throw an {@link InvariantError}.
     * @see {@link ModuleWithRoles.getAllRoleMembers | getAllRoleMembers} to get get a list of addresses for all supported roles on the module.
     * @example Say you want to get the list of addresses that are members of the {@link IRoles.minter | minter} role.
     * ```typescript
     * const minterAddresses: string[] = await module.getRoleMemberList("minter");
     * ```
     *
     * @public
     */
    getRoleMembers(role: Role): Promise<string[]>;
    /**
     * Call this to get get a list of addresses for all supported roles on the module.
     *
     * @see {@link ModuleWithRoles.getRoleMembers | getRoleMembers} to get a list of addresses that are members of a specific role.
     * @returns A record of {@link Role}s to lists of addresses that are members of the given role.
     * @throws If the module does not support roles this will throw an {@link InvariantError}.
     *
     * @public
     */
    getAllRoleMembers(): Promise<Partial<Record<Role, string[]>>>;
    /**
     * Call this to grant a role to a specific address.
     *
     * @remarks
     *
     * Make sure you are sure you want to grant the role to the address.
     *
     * @param role - The {@link IRoles | role} to grant to the address
     * @param address - The address to grant the role to
     * @returns The transaction receipt
     * @throws If you are trying to grant does not exist on the module this will throw an {@link InvariantError}.
     *
     * @public
     */
    grantRole(role: Role, address: string): Promise<TransactionReceipt>;
    /**
     * Call this to revoke a role from a specific address.
     *
     * @remarks
     *
     * -- Caution --
     *
     * This will let you remove yourself from the role, too.
     * If you remove yourself from the {@link IRoles.admin | admin} role, you will no longer be able to administer the module.
     * There is no way to recover from this.
     *
     * @param role - The {@link IRoles | role} to revoke
     * @param address - The address to revoke the role from
     * @returns The transaction receipt
     * @throws If you are trying to revoke does not exist on the module this will throw an {@link InvariantError}.
     *
     * @public
     */
    revokeRole(role: Role, address: string): Promise<TransactionReceipt>;
}
