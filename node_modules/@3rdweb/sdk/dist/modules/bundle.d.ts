import { NFTCollection as NFTBundleContract } from "@3rdweb/contracts";
import { BigNumber, BigNumberish } from "@ethersproject/bignumber";
import { TransactionReceipt } from "@ethersproject/providers";
import { BytesLike } from "ethers";
import { ModuleType, Role } from "../common";
import { NFTMetadata } from "../common/nft";
import { ModuleWithRoles } from "../core/module";
import { MetadataURIOrObject } from "../core/types";
/**
 * @beta
 */
export interface BundleMetadata {
    creator: string;
    supply: BigNumber;
    metadata: NFTMetadata;
    ownedByAddress: number;
}
export interface CollectionMetadata {
    creator: string;
    supply: BigNumber;
    metadata: NFTMetadata;
    ownedByAddress: number;
}
/**
 * @beta
 */
export interface INFTBundleCreateArgs {
    metadata: MetadataURIOrObject;
    supply: BigNumberish;
}
export interface INFTCollectionCreateArgs {
    metadata: MetadataURIOrObject;
    supply: BigNumberish;
}
/**
 * @beta
 */
export interface INFTCollectionBatchArgs {
    tokenId: BigNumberish;
    amount: BigNumberish;
}
export interface INFTBundleBatchArgs {
    tokenId: BigNumberish;
    amount: BigNumberish;
}
/**
 * Access this module by calling {@link ThirdwebSDK.getBundleModule}
 * @beta
 */
export declare class BundleModule extends ModuleWithRoles<NFTBundleContract> {
    static moduleType: ModuleType;
    static roles: readonly ["admin", "minter", "pauser", "transfer"];
    /**
     * @override
     * @internal
     */
    protected getModuleRoles(): readonly Role[];
    /**
     * @internal
     */
    protected connectContract(): NFTBundleContract;
    /**
     * @internal
     */
    protected getModuleType(): ModuleType;
    /**
     *
     * Get a single bundle item by tokenId.
     * @param tokenId - the unique token id of the nft
     * @returns A promise that resolves to a `BundleMetadata`.
     */
    get(tokenId: string, address?: string): Promise<BundleMetadata>;
    /**
     * Return all items in the bundle.
     * @returns An array of `INFTBundle`.
     */
    getAll(address?: string): Promise<BundleMetadata[]>;
    balanceOf(address: string, tokenId: string): Promise<BigNumber>;
    balance(tokenId: string): Promise<BigNumber>;
    isApproved(address: string, operator: string, assetContract?: string, assetId?: BigNumberish): Promise<boolean>;
    setApproval(operator: string, approved?: boolean): Promise<TransactionReceipt>;
    transfer(to: string, tokenId: string, amount: BigNumberish): Promise<TransactionReceipt>;
    create(metadata: MetadataURIOrObject): Promise<BundleMetadata>;
    createBatch(metadatas: MetadataURIOrObject[]): Promise<BundleMetadata[]>;
    createAndMint(metadataWithSupply: INFTBundleCreateArgs): Promise<BundleMetadata>;
    createAndMintBatch(metadataWithSupply: INFTBundleCreateArgs[]): Promise<BundleMetadata[]>;
    createWithToken(tokenContract: string, tokenAmount: BigNumberish, args: INFTBundleCreateArgs): Promise<void>;
    createWithErc20(tokenContract: string, tokenAmount: BigNumberish, args: INFTBundleCreateArgs): Promise<void>;
    createWithNFT(tokenContract: string, tokenId: BigNumberish, metadata: MetadataURIOrObject): Promise<void>;
    createWithERC721(tokenContract: string, tokenId: BigNumberish, metadata: MetadataURIOrObject): Promise<void>;
    mint(args: INFTBundleBatchArgs): Promise<void>;
    mintTo(to: string, args: INFTBundleBatchArgs, data?: BytesLike): Promise<void>;
    mintBatch(args: INFTBundleBatchArgs[]): Promise<void>;
    mintBatchTo(to: string, args: INFTBundleBatchArgs[], data?: BytesLike): Promise<void>;
    burn(args: INFTBundleBatchArgs): Promise<TransactionReceipt>;
    burnBatch(args: INFTBundleBatchArgs[]): Promise<TransactionReceipt>;
    burnFrom(account: string, args: INFTBundleBatchArgs): Promise<TransactionReceipt>;
    burnBatchFrom(account: string, args: INFTBundleBatchArgs[]): Promise<TransactionReceipt>;
    transferFrom(from: string, to: string, args: INFTBundleBatchArgs, data?: BytesLike): Promise<TransactionReceipt>;
    transferBatchFrom(from: string, to: string, args: INFTBundleBatchArgs[], data?: BytesLike): Promise<TransactionReceipt>;
    setRoyaltyBps(amount: number): Promise<TransactionReceipt>;
    setModuleMetadata(metadata: MetadataURIOrObject): Promise<TransactionReceipt>;
    setRestrictedTransfer(restricted?: boolean): Promise<TransactionReceipt>;
    /**
     * `getOwned` is a convenience method for getting all owned tokens
     * for a particular wallet.
     *
     * @param _address - The address to check for token ownership
     * @returns An array of BundleMetadata objects that are owned by the address
     */
    getOwned(_address?: string): Promise<BundleMetadata[]>;
}
